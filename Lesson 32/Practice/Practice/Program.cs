namespace Practice
{
    internal class Program
    {

        static void Main(string[] args)
        {

            // ресурсы:
            // файлы
            // буферы в памяти,
            // пространство экрана
            // сетевые подключения
            // базы данных 
            // Чтобы пользоваться ресурсами мы должны выделить для них память.

            // Для доступа к ресурсам нам нужно
            //1. Выделить память для типа (new) 
            //2. Инициализация выделенной памяти, уставовить начальное состояние (конструкторы)
            //3. Использовать ресурс
            //4. Очищаем состояние ресурса
            //5. Освождаем память

            //unsafe

            //Dispose

            // В CLR память для всех ресурсов выделяется из управляемой кучи (managed heap)
            // При инициализации процеса CLR  резервирует область адресного пространства  под кучу. Так же создаётся указатель, который определяет
            // где в куче будет выделена память для следующего объекта.

            //для 32-разрядных до 1.5 гигабайт памяти
            //для 64-разрядных 8 террабайт памяти 

            // При выполнении new CLR делает:
            // 1) Подсчитывает количество байтов для размещения полей типа
            // 2) Прибавляет к полученному значеню количество байтов, необходимых для размещения системных полей объекта.
            // 3) Проверяет, хватает ли зарезервированой области байтов на выделение памяти для того объекта которому мы пишем new.

            //Сборщик мусора -  механизм уничтожения объектов, которые перестали быть нужными нашему приложению.


            // Алгоритм сборки мусора 


            // вызываем new -> оставшегося адресного пространства не хватает для выделения памяти под объект -> CLR вызывает сборщик мусора.

            //CLR использует алгоритм отслеживания ссылок. Алогритм работает только с ссылочным типом -> ссылки храняться в куче.
            // Все переменные ссылочных типов называются корнями.
            
            // Анализ 
            // Маркировка 
            // Сжатие 

            // OutOfMemoryException
            // JIT - компилятор 



            //Функционал сборщика мусора в библиотеке классов .NET представляет класс System.GC.
            //Через статические методы данный класс позволяет обращаться к сборщику мусора.
            //Как правило, надобность в применении этого класса отсутствует.
            //Наиболее распространенным случаем его использования является сборка мусора при работе с неуправляемыми ресурсами,
            //при интенсивном выделении больших объемов памяти, при которых необходимо такое же быстрое их освобождение.

            //Рассмотрим некоторые методы и свойства класса System.GC:

            //Метод AddMemoryPressure информирует среду CLR о выделении большого объема неуправляемой памяти,
            //которую надо учесть при планировании сборки мусора.
            //В связке с этим методом используется метод RemoveMemoryPressure,
            //который указывает CLR, что ранее выделенная память освобождена, и ее не надо учитывать при сборке мусора.


            //Метод Collect приводит в действие механизм сборки мусора.
            //Перегруженные версии метода позволяют указать поколение объектов, вплоть до которого надо произвести сборку мусора

            //Метод GetGeneration(Object) позволяет определить номер поколения,
            //к которому относится переданый в качестве параметра объект

            //Метод GetTotalMemory возвращает объем памяти в байтах,
            //которое занято в управляемой куче

            //Метод WaitForPendingFinalizers приостанавливает работу текущего потока до освобождения всех объектов,
            //для которых производится сборка мусора

          //  var timer = new Timer(TimerCallback, null, 10, 3000);
             Console.ReadLine();




            using (var timer = new Timer(TimerCallback, null, 10, 3000))
            {
                Console.ReadLine();
            }


            //timer.Dispose();

            //timer = null;

            //Освобождение неуправляемых ресурсов подразумевает реализацию одного из двух механизмов:

            //Создание деструктора

            //Реализация классом интерфейса System.IDisposable

            var person = new Person("Egor");


            //Задача создать класс Car освободить память с помозью деструктора(Finalize), и с помощью интерфейса IDisposable ( явный вызов Dipose, using)


        }

        private static void TimerCallback(object o)
        {
            Console.WriteLine("Case" + DateTime.Now);
            GC.Collect();
        }



        //Сборщик мусора с поддержкой поколений.
        // чем младше объект, тем короче его время жизни
        // чем старше объект тем длинее его время жизни
        // сборка мусора в части кучи выполняется быстрее, чем во всей куче.


        // Большие Объекты
        // СLR делит объекты  на малые и большие
        // 85000 байт и больше  (большие)
        
        //CLR работает с большими объектами по след правилам.
        //Память для них выделяется в отдельной части адресного пространства процесса 

        //Для больших объектов не выпонляется сжатие так как для их перемещения потребуется много процессорного времени 

        // Большие объекты всегда считаются частью поколения два поэтому их следует создавать только для ресурсов которые должны жить долго.


        // Два режима сборки мусора :
        // Режим рабочей станции( клиента)
        // Режим сервера (сервера)
    }
}